# Managing UI State

## üìù Your Notes

Elaborate on your learnings here in `src/exercise/01.md`

## Background

Normally an interactive application will need to hold state somewhere. In React,
you use special functions called "hooks" to do this. Common built-in hooks
include:

- `React.useState`
- `React.useEffect`
- `React.useContext`
- `React.useRef`
- `React.useReducer`

Each of these is a special function that you can call inside your custom React
component function to store data (like state) or perform actions (or
side-effects). There are a few more built-in hooks that have special use cases,
but the ones above are what you'll be using most of the time.

Each of the hooks has a unique API. Some return a value (like `React.useRef` and
`React.useContext`), others return a pair of values (like `React.useState` and
`React.useReducer`), and others return nothing at all (like `React.useEffect`).

Here's an example of a component that uses the `useState` hook and an onClick
event handler to update that state:

```jsx
function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(count + 1)
  return <button onClick={increment}>{count}</button>
}
```

`React.useState` is a function that accepts a single argument. That argument is
the initial state for the instance of the component. In our case, the state will
start as `0`.

`React.useState` returns a pair of values. It does this by returning an array
with two elements (and we use destructuring syntax to assign each of those
values to distinct variables). The first of the pair is the state value and the
second is a function we can call to update the state. We can name these
variables whatever we want. Common convention is to choose a name for the state
variable, then prefix `set` in front of that for the updater function.

State can be defined as: data that changes over time. So how does this work over
time? When the button is clicked, our `increment` function will be called at
which time we update the `count` by calling `setCount`.

When we call `setCount`, that tells React to re-render our component. When it
does this, the entire `Counter` function is re-run, so when `React.useState` is
called this time, the value we get back is the value that we called `setCount`
with. And it continues like that until `Counter` is unmounted (removed from the
application), or the user closes the application.

üìú To get a deeper dive on how React keeps track of hooks, read/watch this great
post/talk by [Shawn Wang](https://twitter.com/swyx):
[Getting Closure on Hooks](https://www.swyx.io/getting-closure-on-hooks/)

üìú And here's a reference to
[the hooks official documentation](https://reactjs.org/hooks).

## Exercise

Production deploys:

- [Exercise](https://react-hooks-next.netlify.app/isolated/exercise/01.tsx)
- [Final](https://react-hooks-next.netlify.app/isolated/final/01.tsx)

This exercise should be familiar if you've been through the
[React Fundamentals](https://github.com/kentcdodds/react-fundamentals) workshop
already. Rather than retrieving the value of the input out of the
`form.elements`, we're going to keep track of the value in a state variable
called `username` and when the user submits the form we'll be able to simply
submit that variable.

The benefits of this approach will become apparent in the extra credit. We just
want to get you going on using the `React.useState` hook for the exercise.

## Extra Credit

### 1. üíØ Initialize state

[Production deploy](https://react-hooks-next.netlify.app/isolated/final/01.extra-1.tsx)

Often the reason you split React code into different components is for code
reuse. Just like with regular functions, you can add arguments (props) to
configure the behavior of the function.

üë®‚Äçüíº Let's assume that our `UsernameForm` will be used by different pages of our
application and some of those will need to initialize the `username` state to
something specific, while others will not.

Make the `UsernameForm` accept a prop called `initialUsername` and initialize
the `username` state to that value. (Remember, the value you pass to the
`React.useState` call will be the initial value). You'll also want to make sure
that you handle the situations where an `initialUsername` is not passed and
default that prop to an empty string for when it's not provided.

Go ahead and test it out by updating the `App` component to pass an
`initialUsername` prop along. The test will automatically detect when you've
added the `initialUsername` prop to your component and it can also validate
you've got things working properly as well.

To be clear, start by updating the `App` to have this:

```tsx
<UsernameForm onSubmitUsername={onSubmitUsername} initialUsername="kody" />
```

Once you've finished implementing this feature, you can change that back and
remove the `initialUsername="kody"` if you want.

### 2. üíØ Derived state for validation

[Production deploy](https://react-hooks-next.netlify.app/isolated/final/01.extra-2.tsx)

All state can be classified into two buckets:

- **Managed State:** State that you need to explicitly manage (via
  `React.useState` for example)
- **Derived State:** State that you can calculate based on other state

Not all state needs to be stored, some of it can be derived. For example, let's
say that you have a basket of stuffed animals and your state is:

```tsx
const koalaCount = 4
const owlCount = 6
```

As stuffed animals are added and removed, you need to update those values. But
let's say you want to display a total count of all stuffed animals in the
basket. Do you need to manage that state separately? We definitely could, but we
don't need to (and we shouldn't). You can derive that value from the managed
state that you already have. Add the `koalaCount` and the `owlCount` together
and you get the total.

We have lots of state like this in applications and deriving state can help us
avoid state synchronization bugs. For more on this, read
[Don't Sync State. Derive It!](https://kentcdodds.com/blog/dont-sync-state-derive-it).

For this extra credit, we're going to add some validation. We want to validate
the user's input and display an error message if they get something wrong. Here
are the rules:

1. If username is not all lower-case, display: `'Username must be lower case'`
2. If username is less than 3 characters, display:
   `'Username must be at least 3 characters long'`
3. If username is more than 10 characters, display:
   `'Username must be no longer than 10 characters'`

And finally, if the user clicks "submit" we don't want to call
`onSubmitUsername` unless the input is valid.

üí∞ There are plenty of ways to do this, but as a hint, here are some of the
variables I make in my solution:

- `usernameIsLowerCase`: derived from the `username`
- `usernameIsLongEnough`: derived from the `username`
- `usernameIsShortEnough`: derived from the `username`
- `formIsValid`: derived from `usernameIsLowerCase`, `usernameIsLongEnough`, and
  `usernameIsShortEnough`
- `errorMessage`: derived from `usernameIsLowerCase`, `usernameIsLongEnough`,
  and `usernameIsShortEnough`

So some derived state can be derived from other state!

And then in the `handleSubmit` I check the `formIsValid` value before calling
`onSubmitUsername`.

Display the error message in a `div` with a `id="error-message"` right before
the submit button. We have some `css` on the page so the `error-message` class
will make it `red`. And make sure to not render the `div` if the form is valid.

### 3. üíØ Improve error UX

[Production deploy](https://react-hooks-next.netlify.app/isolated/final/01.extra-3.tsx)

I don't know about you, but having an error message yelling at me before I've
had a chance to fill out the field is really annoying. What I think would be
better is if we wait until the user has focused on the input and then unfocused
it (this is called "blur"-ing the input).

Here's how you create a `onBlur` event handler:

```tsx
function handleBlur() {
  // the user blurred the input...
}
const element = <input onBlur={handleBlur} />
```

So we shouldn't show the error if the form is valid and we shouldn't show it
unless the user has blurred the input. We've already got the validity working,
now we just need to keep track of whether the user has blurred the input. To do
that, we'll need some new state.

Create some new state (with another `React.useState` call) called `showError`
and start it out as `false`. Then use the `onBlur` event to set that state to
`true`.

Also, if the user skips the input and just clicks "submit" it should show the
error as well.

### 4. üíØ Improve error accessibility for screen readers

[Production deploy](https://react-hooks-next.netlify.app/isolated/final/01.extra-4.tsx)

Not everyone can see the user interface you build. And if they can see it, not
everyone can see it very well. So many people use a technology called a "screen
reader" is software that reads the user interface to them.

But sometimes the screen readers need extra help. Crafting good experiences for
users of screen readers is surprisingly difficult for a few reasons:

1. There are many screen readers and they all operate slightly differently
2. While there is [a spec](https://www.w3.org/TR/wai-aria-1.1/), screen reader
   makers acknowledge that many software engineers don't follow it so they try
   to get creative to be more helpful, but that in turn makes it operate
   differently than you might expect.

Because of this, it's good to actually test your software with a real screen
reader (or, even better, multiple) to make sure it behaves well with what you've
built.

Operating systems have screen readers built-in:

- Mac:
  [VoiceOver Desktop](https://support.apple.com/guide/voiceover/welcome/mac)
- iOS:
  [VoiceOver iOS](https://support.apple.com/guide/iphone/turn-on-and-practice-voiceover-iph3e2e415f/ios)
- Windows:
  [Narrator](https://support.microsoft.com/en-us/windows/complete-guide-to-narrator-e4397a0d-ef4f-b386-d8ae-c172f109bdb1)
- Android:
  [TalkBack](https://support.google.com/accessibility/android/topic/3529932)
- Linux: [Orca](https://wiki.gnome.org/action/show/Projects/Orca)

However, there are many alternatives (some paid and others open source). Here
are two:

- [JAWS](https://support.freedomscientific.com/JAWSHQ/JAWSHeadquarters01) (Paid
  and Windows-only)
- [NV Access](https://www.nvaccess.org/) (Open Source and Windows-only)

At the end of the day, it's an enormous challenge to test your software on all
of these screen readers (especially since automated testing in this space is
very difficult to be reliable). So just do your best to follow the spec and
carve out some time to test your software out with screen readers to make sure
that it is sensible.

With that said, our simple form is pretty good, but could be improved. Here are
a few improvements for you to add and try it out with whatever screen reader you
have available (yes, I expect you to actually figure out how to start it up if
you've never done it before).

1. Add `required` to the `<input />`
2. Add `pattern` to the `<input />` that enforces 3-10 lowercase characters (use
   a regex,
   [üìú learn more on mdn](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern))
3. Add `noValidate` to the `<form>` to prevent the browser from displaying error
   messages related to those new attributes because we're already showing a more
   custom error message.
4. Add `name` to the `<form>` to give the form an implicit role of "form" (üìú
   [learn more from the spec](https://www.w3.org/TR/html-aria/#docconformance)).
5. Add `role="alert"` to the error message `div` so screen readers will read the
   message. (üìú
   [learn more on mdn](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_alert_role)).

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Hooks%20%F0%9F%8E%A3&e=01%3A%20Managing%20UI%20State&em=lethang7794%40gmail.com).
