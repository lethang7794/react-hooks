# DOM Side-Effects

## üìù Your Notes

Elaborate on your learnings here in `src/exercise/05.md`

## Background

Often when working with React you'll need to interact with the DOM directly. You
may need to use a vanilla-js (non-framework-specific) library that needs to
interact with directly with the DOM. Often to make a UI accessible you need to
consider focus management requiring you to call `.focus()` on an input.

Remember that when you do: `<div>hi</div>` that's actually syntactic sugar for a
`React.createElement` so you don't actually have access to DOM nodes in your
render method. In fact, DOM nodes aren't created at all until the
`ReactDOM.render` method is called. Your component's render method is really
just responsible for creating and returning React Elements and has nothing to do
with the DOM in particular.

So to get access to the DOM, you need to ask React to give you access to a
particular DOM node when it renders your component. The way this happens is
through a special prop called `ref`.

Here's a simple example of using the `ref` prop:

```tsx
function MyDiv() {
  const myDivRef = React.useRef<HTMLDivElement>(null)
  React.useEffect(() => {
    const myDiv = myDivRef.current
    // myDiv is the div DOM node!
    console.log(myDiv)
  }, [])
  return <div ref={myDivRef}>hi</div>
}
```

After the component has been rendered, it's considered "mounted." That's when
the React.useEffect callback is called and so by that point, the ref should have
its `current` property set to the DOM node. So often you'll do direct DOM
interactions/manipulations in the `useEffect` callback.

Every element has a special `ref` prop (as shown above). You pass a ref to that
prop and React will give you a reference to the thing that's created for that
element.

üìú Learn more about `useRef` from the docs:
https://reactjs.org/docs/hooks-reference.html#useref

ü¶â Note, sometimes the DOM interaction will make observable changes to the UI.
In those cases you'll want to use `useLayoutEffect` and we cover that in the
"Advanced React Hooks" workshop.

ü¶â A ref is basically state that's associated to a React component that will not
trigger a rerender when changed. So you can store whatever you'd like in a ref,
not just DOM nodes. Think of a ref like this:

```tsx
const myRef = React.useState({current: null})[0]

// you are now free to mutate the value of myRef.current
```

Keep in mind, React can't track when you change a ref value. That's part of it's
appeal in some cases and it can cause trouble in others. You'll develop the
intuition of when to use which over time, but in general it's best to start with
state if you're unsure and then move to a ref if you decide you don't want a
rerender when it's updated. We'll dive deeper into non-DOM refs in future
workshops.

## Exercise

Production deploys:

- [Exercise](https://react-hooks-next.netlify.app/isolated/exercise/05.tsx)
- [Final](https://react-hooks-next.netlify.app/isolated/final/05.tsx)

For this extra credit we're going to auto-focus on the username input if there's
an error after submitting. This is a common practice for accessibility purposes
(to focus on the first input that has an error after a form submission).

So for this exercise you're going to use `useRef`. The example above should be
enough to get you working. You'll pass the ref you create to the input and then
in a `useEffect` you'll call `.focus()` on the input element whenever the error
is displayed.

## Extra Credit

### 1. üíØ Side-effect cleanup

In this extra credit we're going to use a completely different example. We're
going to make a `<Tilt />` component that renders a div and uses the
`vanilla-tilt` library to make it super fancy.

The thing is, `vanilla-tilt` works directly with DOM nodes to setup event
handlers and stuff, so we need access to the DOM node. But because we're not the
one calling `document.createElement` (React does) we need React to give it to
us.

So in this exercise we're going to use a `ref` so React can give us the DOM node
and then we can pass that on to `vanilla-tilt`.

Additionally, we'll need to clean up after ourselves if this component is
unmounted. Otherwise we'll have event handlers dangling around on DOM nodes that
are no longer in the document which can cause a memory leak.

To be clear about the memory leak, just imagine what would happen if we mount a
tilt element, then unmount it (without cleaning up). Those DOM nodes hang around
because the event listeners are still listening to events on them (even though
they're no longer in the document). Then let's say we mount a new one and
unmount that again. Now we have two sets of DOM nodes that are still in memory,
but not being used. We keep doing this over and over again and eventually our
computer is just keeping track of all these DOM nodes we don't need it to.
That's what's called a memory leak. So it's really important we clean up after
ourselves to avoid the performance problems associated with memory leaks.

NOTE: Because this extra credit is a completely different example, you've got
another starting point file in: `src/exercise/05.extra-1.tsx`. üê® and üí∞ will be
there to help you get that working.

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Hooks%20%F0%9F%8E%A3&e=05%3A%20useRef%20and%20useEffect%3A%20DOM%20interaction&em=lethang7794%40gmail.com).
